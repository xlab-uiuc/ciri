Raw json:

{'hasError': True, 'errParameter': ['dfs.client.https.keystore.resource', 'dfs.namenode.backup.address', 'dfs.namenode.fs-limits.min-block-size', 'dfs.namenode.posix.acl.inheritance.enabled', 'dfs.client.socketcache.capacity', 'dfs.datanode.data.transfer.bandwidthPerSec', 'dfs.mover.address', 'dfs.webhdfs.oauth2.enabled'], 'reason': ['Resource file from which ssl client keystore information will be extracted', 'The backup node server address and port. If the port is 0 then the server will start on a free port.', 'Minimum block size in bytes, enforced by the Namenode at create time. This prevents the accidental creation of files with tiny block sizes (and thus many blocks), which can degrade performance. Support multiple size unit suffix(case insensitive), as described in dfs.blocksize.', 'Set to true to enable POSIX style ACL inheritance. When it is enabled and the create request comes from a compatible client, the NameNode will apply default ACLs from the parent directory to the create mode and ignore the client umask. If no default ACL found, it will apply the client umask.', 'Socket cache capacity (in entries) for short-circuit reads. If this value is set to 0, the client socket cache is disabled.', 'Specifies the maximum amount of bandwidth that the data transfering can utilize for transfering block when BlockConstructionStage is PIPELINE_SETUP_CREATE and clientName is empty. When the bandwidth value is zero, there is no limit.', 'The hostname used for a keytab based Kerberos login. Keytab based login can be enabled with dfs.mover.keytab.enabled.', 'If true, enables OAuth2 in WebHDFS']}

Final result:

There are 8 misconfiguration parameters in the input: dfs.client.https.keystore.resource	dfs.namenode.backup.address	dfs.namenode.fs-limits.min-block-size	dfs.namenode.posix.acl.inheritance.enabled	dfs.client.socketcache.capacity	dfs.datanode.data.transfer.bandwidthPerSec	dfs.mover.address	dfs.webhdfs.oauth2.enabled
[Ciri] Reason for dfs.client.https.keystore.resource: Resource file from which ssl client keystore information will be extracted
[Ciri] Reason for dfs.namenode.backup.address: The backup node server address and port. If the port is 0 then the server will start on a free port.
[Ciri] Reason for dfs.namenode.fs-limits.min-block-size: Minimum block size in bytes, enforced by the Namenode at create time. This prevents the accidental creation of files with tiny block sizes (and thus many blocks), which can degrade performance. Support multiple size unit suffix(case insensitive), as described in dfs.blocksize.
[Ciri] Reason for dfs.namenode.posix.acl.inheritance.enabled: Set to true to enable POSIX style ACL inheritance. When it is enabled and the create request comes from a compatible client, the NameNode will apply default ACLs from the parent directory to the create mode and ignore the client umask. If no default ACL found, it will apply the client umask.
[Ciri] Reason for dfs.client.socketcache.capacity: Socket cache capacity (in entries) for short-circuit reads. If this value is set to 0, the client socket cache is disabled.
[Ciri] Reason for dfs.datanode.data.transfer.bandwidthPerSec: Specifies the maximum amount of bandwidth that the data transfering can utilize for transfering block when BlockConstructionStage is PIPELINE_SETUP_CREATE and clientName is empty. When the bandwidth value is zero, there is no limit.
[Ciri] Reason for dfs.mover.address: The hostname used for a keytab based Kerberos login. Keytab based login can be enabled with dfs.mover.keytab.enabled.
[Ciri] Reason for dfs.webhdfs.oauth2.enabled: If true, enables OAuth2 in WebHDFS
